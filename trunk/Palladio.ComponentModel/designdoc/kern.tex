\section{Datenhaltung im Modellkern}

Der Modellkern, dessen Hauptaufgabe die Verwaltung der Daten darstellt, bildet den wichtigsten Bestandteil des Komponentenmodells mit den im ersten Teil des Kapitels erläuterten Anforderungen. Es folgt die Präsentation von drei Ideen zu deren Umsetzung. Abschließend wird die in dieser Version des Komponentemodells implementierte Variante ausführlich erläutert.

\subsection{Anforderungen an den Modellkern}

\begin{itemize}
\item \textbf{Speicherung}\\
Der Modellkern muss in der Lage sein, alle Daten zur Laufzeit des nutzenden Programms zu speichern. Zu den Daten gehören die Entitäten des Komponentenmodells mit ihren Attributen. Die Struktur der Attribute beschränkt sich hierbei nicht auschließlich auf Standartdatentypen. Es müssen beliebige z.T. zur Entwurfszeit unbekannte Datenstrukturen speicherbar sein. Weiterhin müssen die Beziehungen zwischen den Entitäten (z.B. Komponente \emph{A} enthält Komponente \emph{B}) festgehalten werden. 

\item \textbf{Konsistenzprüfung}\\
Wie eingangs in der Architekturbescheibung erläutert besteht die Aufgabe des Modellkerns nicht in der Implementierung der Konsistenzprüfung des theoretischen Modells. Somit sollte im Idealfall prinzipiell erst einmal alles abspeicherbar sein. Da die Umsetzung dieser Anforderung viele ungenutzte und zu Lasten der Komplexität fallende Möglichkeiten bietet, ist die Nutzung von Wissen über das theoretische Modell bei der Konzeption der Datenhaltung sinnvoll einzubringen. Verstöße gegen die sich hierraus ergebenen Beschränkungen sind dann jedoch durch den Modellkern abzufangen und entsprechend zu behandeln. Soll beispielsweise entsprechend dem o.g. Beispiel die Komponente \emph{B} der Komponente \emph{A} hinzugefügt werden, so ist vom Modell diese Beziegung zu speichern. Setzt die gewählte Speicherstruktur hierbei das vorhandensein von Komponente A vorraus, so ist das durch den Modellkern sicherzustellen. Dieser kann dann entweder die Speicherung ablehnen oder selbständig eine Komponente A erzeugen.

\item \textbf{Zugriffsmethoden}\\
Die dritte Anforderung an den Modellkern stellen die Zugriffsmethoden dar. Da in die Datenhaltung, wie oben erläuert, nicht das vollständige Wissen über das theoretische Modell zu implementieren ist, können keine hierauf zugeschnittenen Zugriffsmethoden zur Verfügung gestellt werden. Es ist also eine Schnittstelle zu schaffen, die flexiblen Zugriff auf alle gespeicherten Daten bereitstellt. Bestehen im Modell der Datenhaltung bereits Beziehungen zwischen den Daten, so bietet sich deren Nutzung beim Zugriff an.
Weiterhin wichtig ist sowohl bei den Zugriffsmethoden als auch bei der Speicherung die Geschwindigkeit. Dieser Teil des Modells bildet, wie bereits erläutert, die Datenhaltung für die laufende Anwendung. Sorgt die Arbeit auf dem Modell für zu hohe Latenz, so leidet die Nutzbarkeit der Anwendung hierrunter stark.

\end{itemize}

Nachdem die grundlegenden Anforderungen an den Modellkern erarbeitet wurden, folgt die Vorstellung von Ideen zu deren Umsetzung.

\subsection{Ideen zur Umsetzung}
\label{sec:kern:beschr:idee}

Zur Umsetzung des Modellkerns kommen eine Reihe von Strategien in Frage, von denen drei im Folgenden gegeneinander abgegrenzt werden. 

Die erste Strategie bedient sich ausschließlich objektorientierter Konzepte. Hierbei werden die Entitäten durch Klasseninstanzen und Beziehungen zwischen diesen durch Referenzen auf andere Instanzen modelliert. Vorteile dieser Variante ergeben sich aus guter Modellierbarkeit von Spezialisierung, problemloser Speicherung von Attributen unbekannten Typs und hoher Geschwindigkeit. Erfahrungen haben gezeigt, dass sich bei der Umsetzung dieses Konzeptes Probleme hinsichtlich Wartbarkeit und Erweiterbarkeit ergeben, die sich auf die starke Abhängigkeit der Klassen untereinander zurückführen lassen. Ebenfalls schwierig zu modellieren sind auf diese Art zirkuläre Abhänigkeiten.

Der zweite Ansatz bedient sich einer relationalen oder einer objektrelationalen Datenbank. Die Entitäten werden hierbei in entsprechenden Tabellen der Datenbank gespeichert. Die Beziehungen zwischen den Entitäten lassen sich in der Datenbank entsprechend als Beziehungen zwischen den Tabellen modellieren. Details zum Entwurf solcher Datenbankschemata und deren Nutzung sei an dieser Stelle auf entsprechende Literatur (z.b. \cite{lit:db}) verwiesen. Vorteil dieses Ansatzes liegt in der guten Infrastruktur zum Speichern, Laden und anfragen von Daten. Nachteilig ist jedoch das zur Entwurfszeit festgelegte Datenschema, welches den unbekannten Attributen nicht gerecht wird. Weiterhin bringt eine Datenbank viel Funktionalität mit, welche i.A. im Rahmen der Datenhaltung einer Anwendung (z.B. eines Editors für das Komponentenmodell) zuviel Aufwand bedeutet. Seitens der Geschwindigkeit kann die Datenbank mit dem ersten Ansatz in Hinblick auf den Anwendungsfall Komponentenmodell nicht mithalten.

Die dritte hier vorgestellte und gleichzeitig von uns verwendete Idee kombiniert die Vorteile der beiden vorherigen Varianten. Die durch ihre Attribute charakterisierten Entitäten werden gemäß dem ersten Ansatz in Form von Objektinstanzen gespeichert. Die Beziehungen zwischen diesen Entitäten hält eine Art Datenbank. Somit lassen sich problemlos alle Art von (auch unbekannten) Attributen speichern. Die verwendete Datenbank bietet performante und flexible Möglichkeiten, Beziehungen zwischen den Entitäten zu erfragen.

Es folgt die detailierte Beschreibung der von uns umgetzten Variante. 

\subsection{Beschreibung der umgesetzten Variante}

Wie im vorherigen Abschnitt kurz erläutert handelt es sich bei den Entitäten um reine Datenkontainer. Es existieren im Komponentenmodell zwei Arten von Entitäten, interne und externe Enitäten. Alle internen Entitäten besitzen neben einer ID einen Namen und eine Liste von zur Laufzeit frei wählbaren Attributen. Je nach Typ der Entität existieren zusätzliche jedoch zur Entwurfszeit festgelegte Attribute (z.B. der Typ einer Komponente). Zu internen Entitäten gehören Komponenten, Schnittstellen, Verbindungen und Signaturen.

Externe Entitäten zeichnen sich durch ihre zur Entwurfszeit unbekannte Struktur aus. Ihnen ist ausschließlich eine ID und eine Typ-ID gemeinsam. Die ID sorgt für die Eindeutigkeit der Instanz in einem Modell, die Typ-ID dient der Identifikation der verwendeten Implementation der externen Entität. Im Komponentenmodell gehören Protokolle und Service-Effekt-Spezifikationen (siehe \cite{lit:reu}) zu den externen Entitäten, da diese auf verschiedenste Weise (z.B. durch Finite State Machines) implementierbar sind.

Die Schnittstellen aller Entitäten sind in der derzeitigen Implementierung des Komponentenmodells im Namensraum \verb+Palladio.ComponentModel.ModelEntities+ zu finden. Es folgt eine genauere Beschreibung der Realisierung der internen und externen Entitäten.
  
\subsubsection{Realisierung interner Entitäten}
Das Interface \verb+IComponentModelEntity+ bildet die Basisschnittstelle aller internen Entitäten. Es definiert Zugriffsmethoden auf die ID, den Namen und die Attribute, wobei auf ID auschließlich lesend, auf Name und die Attribute zusätzlich auch schreibend zugegriffen werden kann. Während der Name direkter Bestandteil der Schnittstelle ist, ist der Zugriff auf die Attribute im Interface \verb+IAttributable+ definiert. Dieses ist Teil des Palladio-Attribut-Konzepts und wird von \verb+IComponentModelEntity+ geerbt. Ebenso ist ID nicht direkt im Interfaces definiert sondern wird von einem Basisinterfaces ererbt. Eine detailierte Betrachtung der Identifizierung von Entitäten ist in Kapitel \ref{sec:kern:beschr:ids} zu finden. Alle internen Entitäten des Komponentenmodells erhalten spezialisierte Schnittstellen, die pro Entität zusätzliche Attribute definieren.

Sowohl Basisinterface als auch die spezialisierten Schnittstellen sind von außerhalb zugreifbar. Die Implementierungen der Interfaces sind verborgen. Sie lassen sich unter Verwendung der Klasse \emph{EntityFactory} instanzieren. In der derzeitigen Version des Komponentenmodells ist diese Fabrik ebenfalls nicht von außen nutzbar. Sie wird ausschließlich durch die Builder-Schicht (vgl. Kapitel \ref{sec:arch}) genutzt. Sinn dieser Entscheidung ist die Vermeidung von fremden möglicherweise fehlerhaften Implementierungen der Enitäten. 

Diverse Anforderungen nach Erweiterbarkeit der Entitäten um spezialisierte direkt über die Schnittstellen zugreifbare Attribute erzwingen an dieser jedoch möglicherweise eine Änderung der Designentscheidung. So besteht die Möglichkeit, die Implementierung der Entitäten in Form einer Fabrik von außen konfigurierbar zu gestalten.  

\subsubsection{Realisierung der externen Entitäten}

Im Gegensatz zu den internen Entitäten besteht bei den externen Entitäten bereits auch in dieser Version des Kompomentenmodells eine Unabhängigkeit zur Implementierung. Dies ist notwendig, da zur Entwurfszeit weder Informationen über Attribute der Entitäten noch über interne Strukturen bekannt sind. Die einzigen in den Schnittstellen definierten Attribute sind eine ID zur eindeutigen Identifizierung im Modell und eine Typ-ID zur Zuordnung der Implementierung.

Aufgrund dieser Tatsache bestehen seitens des Komponentenmodells keinerlei Anfrage- oder Modifikationsmöglichkeiten der externen Entitäten. Es ist Aufgabe der nutzenden Anwendung hier eine geeignete Infrastruktur zur Verfügung zu stellen.

Nachdem die Realisierung der sowohl internen als auch externen Entitäten verdeutlicht wurde, folgt nun die Beschreibung des verwendeten ID-Konzepts und der Speicherung der Entitäten im Modell.

\subsubsection{Identifizierung und lokale Speicherung von Entitäten}
\label{sec:kern:beschr:ids}

Die Identifizierung der Entitäten ist fundamentale Aufgabe im Modell. Sämtliche Anfragen an das Modell oder Modifikationen an der Struktur des Modells verwenden nicht die Entitäten selber sondern deren IDs. Vorteil hierbei ist die Unabhängikeit der gesamten Infrastruktur des Komponentmodells von den Implementierungen der Entitäten. Bessere Wartbarkeit und geringere Fehleranfälligkeit sind die Konsequenz hieraus. Weiterhin erhält die nutzende Anwendung die Möglichleit der granularen Zuordnung von Rechten. So kann bestimmten Teilen die Verwendung von beispielsweise der Builder-Schicht gewährt werden, ohne direkten Zugriff auf die Entitäten selber zulassen zu müssen. Proxy-Konzepte sind unter anderem auf diese Art mit wenig Aufwand umsetzbar.    

Zur Vermeidung von Fehlern bei der Nutzung des Komponentenmodells wurden die IDs typisiert. Dies bedeutet, dass beispielsweise die Anfrage an ein Interface nur unter Verwendung einer Interface-ID gestellt werden kann. Um Anfragen die Möglichkeit der Übergabe einer beliebigen ID zu ermöglichen \footnote{QueryRepository bietet beispielsweise die Möglichkeit, die zu einer übergebenen ID gehörige Entität egal welcher Art zurückzugeben.}, erben alle IDs von einem Basisinterface. 

Sowohl das Basisinterface aller IDs als auch das Basisinterfaces der Entitäten, in dem die lesende Zugriffsmethode auf die ID definiert ist, sind Bestandteil des vom Komponentenmodell unabhängigen Projektes \verb+Palladio.Identifier+. Ziel dieser Ausgliederung ist die Wiederverwendbarkeit des ID-Konzepts und die dadurch gewonnene Kombinationsmöglichkeit sonst unabhängiger Projekte. Zusätzlich zu den beiden Interfaces werden Möglichkeiten zur Verwaltung von Entitäten und IDs zur Verfügung gestellt. Das Basisinterface aller IDs definiert die ausschließlich lesbare Eigenschaft \verb+Key+ vom Type \verb+System.String+. Dieser Umweg musste gewählt werden, um die oben erwähnte Möglichkeit zur Verwendung von typisierten IDs zu schaffen. Der Datentyp  \verb+System.String+ ist weder durch ein Interface gekapselt, noch ist er erweiterbar durch Ableitung. Die ebenfalls im Projekt zu findene Standartimplementierung einer ID bedient sich der String-Repräsentation einer GUID als Key.

Das derzeitige Komponentenmodell stellt zur Erzeugung von IDs die von außen nutzbare Fabrik \verb+ComponentModelIdentifier+ zur Verfügung. Es wird von dieser Fabrik für alle erzeugten IDs dieselbe alle Klasse \verb+InternalEntityIdentifier+ verwendet. Als Folge hieraus lassen sich IDs unterschiedlichen Typs ineinander casten. Dies sollte bei der Nutzung des Komponentenmodells keinerlei Probleme bereiten, da die Klasse selber nicht von außen sichtbar ist. 

Wie in Kapitel \ref{sec:kern:beschr:idee} bereits angedeutet, werden die Entitäten zur Laufzeit der Anwendung direkt als Objektinstanzen gespeichert. Die gekapselte Hashtabelle ist ebenfalls Bestandteil des Identifier-Projekts. Jede Entität des Komponentenmodells ist in dieser Tabelle mit ihrer ID als Schlüssel zugreifbar. Iteratoren ermöglichen einfachen Zugriff auf alle Entitäten.

Nachdem das Konzept der internen und externen Entitäten inklusive der lokalen Speicherung und Identifizierung hinreichend dargestellt wurde, geht der folgende Abschnitt auf die Realisierung der Beziehungen zwischen den Entitäten ein. 

\subsubsection{Lokale Speicherung der Beziehungen}
\label{sec:kern:beschr:dataset}

Die Speicherung der Beziehungen zwischen den Entitäten ist derzeit unter der Verwendung des \emph{ADO.Net-Dataset} realisiert. Es handelt sich hierbei um eine Datenverwaltung ähnlich einer relationalen Datenbank welche jedoch lokal im Kontext der Anwendung instanziert ist. Realisiert sind Datasets in einem Objektmodell bestehend aus Zeilen und Spalten innerhalb von Tabellen.  In Datasets können ebenso wie in realtionalen Datenbanken Beziehungen und Einschränkungen definiert werden. Die Struktur eines Datasets wird in Form eines XML-Schemas definiert. Die enthaltenen Daten können sind direkt in XML serialisierbar. Datasets lassen sich in typisiert und nicht typisiert untertteilen. Typisierte Dataset erweitern die Basisklasse \verb+Dataset+ um Zugriffsmethoden welche direkt auf dem zugrundeliegenden Schema aufbauen\cite{lit:dataset}.

Die Verwendung eines Datasets im Kontext des Komponentenmodells zeichnet sich durch viele Vorteile aus. Die vollständige Integration in die Anwendung erfordert keinerlei zusätzliche Infrastruktur. Die Objektnatur der Datasets ermöglicht Navigation über Tabellen hinweg durch untereinander verlinkte Tabellenzeilen. Anfragen an eine Tabelle können in SQL ähnlicher Form gestellt werden.

Nachteilig wirkt die fehlende Möglichkeit der Anfrage über mehrere Tabellen hinweg in Form von beispielsweise Joins. Hier müssen Tabellen einzeln abgefragt und die Ergebnisse für weitere Anfragen verwendet werden. Sinnvoll wäre weiterhin die Möglichkeit der freien Wahl der Datentypen in einem Dataset. Die bisher in einer Hashtabelle gehaltenen Entitäten (vgl. \ref{sec:kern:beschr:ids}) könnten so direkt in eine Tabelle des Datasets integriert werden. Das Konzept der XML-Serialisierbarkeit von Dataset erschwert möglicherweise die Umsetzung einer solchen Erweiterung.

Es folgt die Beschreibung des für das Komponentenmodell entworfenen Schemas welches in Abbildung \ref{fig:dataset} dargestellt ist.

\begin{figure}[ht]
 \centering \includegraphics[scale=0.53]{dataset.png}
 \caption{.NET Dataset des Modellkerns}
 \label{fig:dataset}
\end{figure}

Die anfänglich geplante stikte Trennung von \emph{Type}-, \emph{Implementierungs}- und \emph{Deployment}-Ebene gemäß \cite{lit:cm} konnte aufgrund von Abhängigkeiten anderer Projekte in dieser Version des Modells nicht eingehalten werden. Aufgrund dieser Tatsache werden zukünftige Änderungen starken Einfluss auf das bisherige Schema haben. Unabhängig davon soll zum besseren Verständnis des derzeitigen Modells das aktuelle Schema erläutert werden. Dies kann ebenfalls als praktisches Beispiel zum Umgang mit Datasets im Kontext des Komponentenmodells dienen.

Um in relationalen Datenbanken Beziehungen zwischen Entitäten herstellen zu können, müssen die Entitäten selber in Form einer Tabelle in der Datenbank vorliegen. Analog verhält sich die Speicherung der Beziehungen in einem Dataset. Da die Entitäten selbst jedoch als Objektinstanzen in einer Hashtabelle (vgl. \ref{sec:kern:beschr:dataset}) gehalten werden, sollten diese zur Vermeidung von Redundanz nicht vollständig in der Tabelle des Datasets gehalten werden. An dieser Stelle genügen Schlüssel- und Fremschlüsselattribute der Entitäten, um Beziehungen zwischen diesen modellieren zu können. Die folgende Auflistung erläutert die Dataset-Tabellen, welcher der Speicherung der Schlüsselattribute der Entitäten dienen.

\begin{itemize}
	\item \textbf{Components}\\
	Das logische Komponentenmodell enthält gemäß \cite{lit:cm} zwei Arten von Komponenten, zusammengesetzte Komponenten (\emph{composite components}) und Basiskomponenten (\emph{basic components}). Beide sind Spezialisierungen von Komponenten, die sich jedoch nur in den Beziehungen zu anderen Entitäten unterscheiden. Die Art und Anzahl der Attribute beider Komponententypen sind gleich. Somit bietet sich als Modellierungsart die Auflösung der Spezialisierung unter Verwendung eines Typ-Attributs (vgl. \cite{lit:db}) an. Somit setzt sich die Tabelle \emph{Components} aus den Attributen guid (ID der Komponente) und type (Typ der Komponente) zusammen. 
	
	\item \textbf{Interfaces}\\
	\item \textbf{Signatures}\\
	\item \textbf{DelegationConnections}\\
	\item \textbf{AssemblyConnections}\\
	\item \textbf{Protocols}\\
	\item \textbf{Seffs}\\	
\end{itemize}

\subsubsection{Schnittstelle nach außen}
%lowlevel builder